// services/vulnerabilityScannerRace/vulnerabilityScannerEngine.ts

import Arena from '../../models/Arena';
import ArenaProgress from '../../models/ArenaProgress';
import mongoose from 'mongoose';

/**
 * ğŸ” Vulnerability Scanner Race Engine
 * 
 * ì·¨ì•½ì  ì œì¶œ ê²€ì¦, ì ìˆ˜ ê³„ì‚°, ê²Œì„ ìƒíƒœ ê´€ë¦¬
 */

interface VulnerabilitySubmission {
  arenaId: string;
  userId: string;
  vulnType: string;
  endpoint: string;
  parameter: string;
  payload: string;
}

interface SubmissionResult {
  success: boolean;
  message: string;
  isCorrect: boolean;
  isFirstBlood: boolean;
  pointsAwarded: number;
  breakdown?: {
    basePoints: number;
    firstBloodBonus: number;
    speedBonus: number;
    comboBonus: number;
  };
  vulnInfo?: {
    vulnId: string;
    vulnType: string;
    vulnName: string;
  };
}

/**
 * âœ… ì·¨ì•½ì  ì œì¶œ ì²˜ë¦¬
 */
export async function processVulnerabilitySubmission(
  submission: VulnerabilitySubmission
): Promise<SubmissionResult> {
  
  const { arenaId, userId, vulnType, endpoint, parameter, payload } = submission;

  try {
    // 1. Arena ì¡°íšŒ
    const arena = await Arena.findById(arenaId).populate('scenarioId');
    
    if (!arena) {
      return {
        success: false,
        message: 'Arena not found',
        isCorrect: false,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    if (arena.status !== 'started') {
      return {
        success: false,
        message: 'Arena not started',
        isCorrect: false,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    const scenario = arena.scenarioId as any;
    const scenarioData = scenario.data;
    
    // 2. ì œì¶œí•œ ì·¨ì•½ì  ì°¾ê¸°
    const vulnerability = scenarioData.vulnerabilities.find((v: any) => 
      v.vulnType === vulnType && 
      v.endpoint === endpoint &&
      (v.parameter === parameter || v.parameter === '')
    );

    if (!vulnerability) {
      // ì˜ëª»ëœ ì œì¶œ - í˜ë„í‹°
      return await applyInvalidSubmissionPenalty(arenaId, userId, {
        vulnType,
        endpoint,
        parameter,
        payload
      });
    }

    // 3. ì´ë¯¸ ë°œê²¬í–ˆëŠ”ì§€ í™•ì¸
    const alreadyDiscovered = await checkIfAlreadyDiscovered(
      arenaId, 
      userId, 
      vulnerability.vulnId
    );

    if (alreadyDiscovered) {
      return {
        success: false,
        message: 'You already discovered this vulnerability',
        isCorrect: true,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    // 4. í˜ì´ë¡œë“œ ê²€ì¦
    const isValidPayload = await validatePayload(vulnerability, payload);
    
    if (!isValidPayload) {
      // ì˜¬ë°”ë¥¸ ì·¨ì•½ì ì´ì§€ë§Œ í˜ì´ë¡œë“œê°€ í‹€ë¦¼ - í˜ë„í‹°
      return await applyInvalidSubmissionPenalty(arenaId, userId, {
        vulnType,
        endpoint,
        parameter,
        payload
      });
    }

    // 5. First Blood í™•ì¸
    const isFirstBlood = await checkFirstBlood(arenaId, vulnerability.vulnId);

    // 6. ì ìˆ˜ ê³„ì‚°
    const points = await calculatePoints(
      arenaId,
      userId,
      vulnerability,
      isFirstBlood
    );

    // 7. Arenaì— ë°œê²¬ ê¸°ë¡
    await recordDiscovery(arenaId, userId, vulnerability.vulnId, points.total);

    // 8. ArenaProgress ì—…ë°ì´íŠ¸
    await updatePlayerProgress(
      arenaId,
      userId,
      vulnerability,
      payload,
      isFirstBlood,
      points
    );

    // 9. ì™„ë£Œ ì²´í¬
    await checkGameCompletion(arenaId);

    return {
      success: true,
      message: `âœ… ${vulnerability.vulnName} discovered!`,
      isCorrect: true,
      isFirstBlood,
      pointsAwarded: points.total,
      breakdown: {
        basePoints: points.base,
        firstBloodBonus: points.firstBlood,
        speedBonus: points.speed,
        comboBonus: points.combo
      },
      vulnInfo: {
        vulnId: vulnerability.vulnId,
        vulnType: vulnerability.vulnType,
        vulnName: vulnerability.vulnName
      }
    };

  } catch (error) {
    console.error('[processVulnerabilitySubmission] Error:', error);
    return {
      success: false,
      message: 'Error processing submission',
      isCorrect: false,
      isFirstBlood: false,
      pointsAwarded: 0
    };
  }
}

/**
 * ğŸ” í˜ì´ë¡œë“œ ê²€ì¦
 */
async function validatePayload(
  vulnerability: any,
  payload: string
): Promise<boolean> {
  
  const { validation } = vulnerability;
  
  if (!validation) {
    return true; // ê²€ì¦ ë¡œì§ì´ ì—†ìœ¼ë©´ í†µê³¼
  }

  const { validationMethod, expectedPayload } = validation;

  switch (validationMethod) {
    case 'exact':
      // ì •í™•íˆ ì¼ì¹˜
      return payload === expectedPayload;
    
    case 'contains':
      // í¬í•¨ ì—¬ë¶€
      return payload.includes(expectedPayload || '');
    
    case 'regex':
      // ì •ê·œí‘œí˜„ì‹
      const pattern = validation.validationCriteria?.pattern;
      if (pattern) {
        const regex = new RegExp(pattern);
        return regex.test(payload);
      }
      return true;
    
    case 'stored':
    case 'unauthorized_access':
    case 'missing_token':
      // ì‹¤ì œ ê²€ì¦ì´ í•„ìš”í•œ ê²½ìš° - ê°„ë‹¨í•˜ê²Œ expectedPayload í¬í•¨ ì—¬ë¶€ë¡œ ì²´í¬
      if (expectedPayload) {
        return payload.toLowerCase().includes(expectedPayload.toLowerCase());
      }
      return true;
    
    default:
      return true;
  }
}

/**
 * ğŸ©¸ First Blood í™•ì¸
 */
async function checkFirstBlood(
  arenaId: string,
  vulnId: string
): Promise<boolean> {
  
  const arena = await Arena.findById(arenaId);
  if (!arena) return false;

  const modeSettings = arena.modeSettings?.vulnerabilityScannerRace;
  if (!modeSettings) return false;

  const vuln = modeSettings.vulnerabilities.find((v: any) => v.vulnId === vulnId);
  if (!vuln) return false;

  return vuln.discovered.length === 0;
}

/**
 * ğŸ¯ ì ìˆ˜ ê³„ì‚°
 */
async function calculatePoints(
  arenaId: string,
  userId: string,
  vulnerability: any,
  isFirstBlood: boolean
): Promise<{
  base: number;
  firstBlood: number;
  speed: number;
  combo: number;
  total: number;
}> {
  
  const arena = await Arena.findById(arenaId).populate('scenarioId');
  const scenario = arena?.scenarioId as any;
  const scoring = scenario?.data?.scoring || {};

  let basePoints = vulnerability.basePoints || 100;
  let firstBloodBonus = 0;
  let speedBonus = 0;
  let comboBonus = 0;

  // First Blood ë³´ë„ˆìŠ¤
  if (isFirstBlood) {
    firstBloodBonus = scoring.firstBloodBonus || 50;
  }

  // ì†ë„ ë³´ë„ˆìŠ¤
  if (arena?.startTime) {
    const elapsedSeconds = (Date.now() - new Date(arena.startTime).getTime()) / 1000;
    const thresholds = scoring.speedBonusThresholds || {};
    
    if (elapsedSeconds < 180) {
      speedBonus = thresholds.under3min || 30;
    } else if (elapsedSeconds < 300) {
      speedBonus = thresholds.under5min || 20;
    } else if (elapsedSeconds < 420) {
      speedBonus = thresholds.under7min || 10;
    }
  }

  // ì½¤ë³´ ë³´ë„ˆìŠ¤
  const progress = await ArenaProgress.findOne({ arena: arenaId, user: userId });
  if (progress && progress.vulnerabilityScannerRace) {
    const discoveries = progress.vulnerabilityScannerRace.discoveries || [];
    
    // ìµœê·¼ 1ë¶„ ì´ë‚´ ë°œê²¬í•œ ì·¨ì•½ì  ê°œìˆ˜
    const oneMinuteAgo = Date.now() - 60000;
    const recentDiscoveries = discoveries.filter((d: any) => 
      new Date(d.discoveredAt).getTime() > oneMinuteAgo
    );
    
    if (recentDiscoveries.length > 0) {
      const comboMultiplier = scoring.comboMultiplier || 5;
      comboBonus = recentDiscoveries.length * comboMultiplier;
    }
  }

  const total = basePoints + firstBloodBonus + speedBonus + comboBonus;

  return {
    base: basePoints,
    firstBlood: firstBloodBonus,
    speed: speedBonus,
    combo: comboBonus,
    total
  };
}

/**
 * ğŸ“ Arenaì— ë°œê²¬ ê¸°ë¡
 */
async function recordDiscovery(
  arenaId: string,
  userId: string,
  vulnId: string,
  pointsAwarded: number
): Promise<void> {
  
  await Arena.updateOne(
    { 
      _id: arenaId,
      'modeSettings.vulnerabilityScannerRace.vulnerabilities.vulnId': vulnId
    },
    {
      $push: {
        'modeSettings.vulnerabilityScannerRace.vulnerabilities.$.discovered': {
          user: new mongoose.Types.ObjectId(userId),
          discoveredAt: new Date(),
          isFirstBlood: await checkFirstBlood(arenaId, vulnId),
          pointsAwarded
        }
      }
    }
  );
}

/**
 * ğŸ“Š í”Œë ˆì´ì–´ ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
 */
async function updatePlayerProgress(
  arenaId: string,
  userId: string,
  vulnerability: any,
  payload: string,
  isFirstBlood: boolean,
  points: any
): Promise<void> {
  
  await ArenaProgress.updateOne(
    { arena: arenaId, user: userId },
    {
      $inc: {
        score: points.total,
        'vulnerabilityScannerRace.vulnerabilitiesFound': 1,
        'vulnerabilityScannerRace.firstBloods': isFirstBlood ? 1 : 0,
        'vulnerabilityScannerRace.speedBonusPoints': points.speed,
        'vulnerabilityScannerRace.comboPoints': points.combo
      },
      $push: {
        'vulnerabilityScannerRace.discoveries': {
          vulnId: vulnerability.vulnId,
          vulnType: vulnerability.vulnType,
          endpoint: vulnerability.endpoint,
          payload,
          discoveredAt: new Date(),
          isFirstBlood,
          basePoints: points.base,
          speedBonus: points.speed,
          comboBonus: points.combo,
          totalPoints: points.total
        },
        'vulnerabilityScannerRace.submissions': {
          vulnType: vulnerability.vulnType,
          endpoint: vulnerability.endpoint,
          parameter: vulnerability.parameter,
          payload,
          isCorrect: true,
          pointsChange: points.total,
          submittedAt: new Date()
        }
      }
    }
  );
}

/**
 * âŒ ì˜ëª»ëœ ì œì¶œ í˜ë„í‹°
 */
async function applyInvalidSubmissionPenalty(
  arenaId: string,
  userId: string,
  submission: {
    vulnType: string;
    endpoint: string;
    parameter: string;
    payload: string;
  }
): Promise<SubmissionResult> {
  
  const arena = await Arena.findById(arenaId).populate('scenarioId');
  const scenario = arena?.scenarioId as any;
  const penalty = scenario?.data?.scoring?.invalidSubmissionPenalty || 5;

  await ArenaProgress.updateOne(
    { arena: arenaId, user: userId },
    {
      $inc: {
        score: -penalty,
        'vulnerabilityScannerRace.invalidSubmissions': 1
      },
      $push: {
        'vulnerabilityScannerRace.submissions': {
          vulnType: submission.vulnType,
          endpoint: submission.endpoint,
          parameter: submission.parameter,
          payload: submission.payload,
          isCorrect: false,
          pointsChange: -penalty,
          submittedAt: new Date()
        }
      }
    }
  );

  return {
    success: true,
    message: `âŒ Incorrect submission. -${penalty} points`,
    isCorrect: false,
    isFirstBlood: false,
    pointsAwarded: -penalty
  };
}

/**
 * ğŸ” ì´ë¯¸ ë°œê²¬í–ˆëŠ”ì§€ í™•ì¸
 */
async function checkIfAlreadyDiscovered(
  arenaId: string,
  userId: string,
  vulnId: string
): Promise<boolean> {
  
  const progress = await ArenaProgress.findOne({ arena: arenaId, user: userId });
  
  if (!progress || !progress.vulnerabilityScannerRace || !progress.vulnerabilityScannerRace.discoveries) {
    return false;
  }

  return progress.vulnerabilityScannerRace.discoveries.some(
    (d: any) => d.vulnId === vulnId
  );
}

/**
 * ğŸ ê²Œì„ ì™„ë£Œ ì²´í¬
 */
async function checkGameCompletion(arenaId: string): Promise<void> {
  
  const arena = await Arena.findById(arenaId).populate('scenarioId');
  if (!arena) return;

  const scenario = arena.scenarioId as any;
  const totalVulns = scenario.data.totalVulnerabilities;
  
  // ëª¨ë“  ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆëŠ”ì§€ í™•ì¸
  const allProgress = await ArenaProgress.find({ arena: arenaId });
  
  const allVulnsFound = allProgress.some((progress: any) => 
    progress.vulnerabilityScannerRace?.vulnerabilitiesFound >= totalVulns
  );

  if (allVulnsFound) {
    // ê²Œì„ ì¢…ë£Œ
    await finalizeGame(arenaId);
  }
}

/**
 * ğŸ¬ ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬
 */
async function finalizeGame(arenaId: string): Promise<void> {
  
  console.log('ğŸ¬ [finalizeGame] Finalizing game...');
  
  // 1. ìˆœìœ„ ê³„ì‚°
  const ranking = await ArenaProgress.find({ arena: arenaId })
    .sort({ score: -1 })
    .populate('user', 'username');

  if (ranking.length === 0) return;

  const winner = ranking[0];

  // 2. Arena ìƒíƒœ ì—…ë°ì´íŠ¸
  await Arena.updateOne(
    { _id: arenaId },
    {
      $set: {
        status: 'ended',
        winner: winner.user,
        firstSolvedAt: new Date()
      }
    }
  );

  // 3. ìŠ¹ìì—ê²Œ completed ì„¤ì •
  await ArenaProgress.updateOne(
    { _id: winner._id },
    {
      $set: {
        completed: true,
        submittedAt: new Date()
      }
    }
  );

  console.log('âœ… [finalizeGame] Game finalized. Winner:', winner.user);
}

/**
 * ğŸ’¡ íŒíŠ¸ ìš”ì²­ ì²˜ë¦¬
 */
export async function requestHint(
  arenaId: string,
  userId: string,
  vulnId: string,
  hintLevel: number
): Promise<{
  success: boolean;
  hint?: string;
  cost?: number;
  message?: string;
}> {
  
  try {
    const arena = await Arena.findById(arenaId).populate('scenarioId');
    if (!arena) {
      return { success: false, message: 'Arena not found' };
    }

    const scenario = arena.scenarioId as any;
    const hints = scenario.data.hints || [];

    const hint = hints.find((h: any) => 
      h.vulnId === vulnId && h.level === hintLevel
    );

    if (!hint) {
      return { success: false, message: 'Hint not found' };
    }

    // ì ìˆ˜ ì°¨ê°
    await ArenaProgress.updateOne(
      { arena: arenaId, user: userId },
      {
        $inc: {
          score: -hint.cost,
          'vulnerabilityScannerRace.hintsUsed': 1
        }
      }
    );

    return {
      success: true,
      hint: hint.text,
      cost: hint.cost
    };

  } catch (error) {
    console.error('[requestHint] Error:', error);
    return { success: false, message: 'Error requesting hint' };
  }
}

/**
 * ğŸ“Š í˜„ì¬ ê²Œì„ ìƒíƒœ ì¡°íšŒ
 */
export async function getGameState(
  arenaId: string,
  userId: string
): Promise<any> {
  
  try {
    const arena = await Arena.findById(arenaId).populate('scenarioId');
    if (!arena) return null;

    const scenario = arena.scenarioId as any;
    const progress = await ArenaProgress.findOne({ arena: arenaId, user: userId });

    // ë°œê²¬ëœ ì·¨ì•½ì  ëª©ë¡
    const discoveredVulns = arena.modeSettings?.vulnerabilityScannerRace?.vulnerabilities || [];
    
    const vulnerabilitiesStatus = discoveredVulns.map((vuln: any) => ({
      vulnId: vuln.vulnId,
      vulnType: vuln.vulnType,
      discovered: vuln.discovered.length > 0,
      discoveredBy: vuln.discovered.map((d: any) => ({
        userId: d.user,
        isFirstBlood: d.isFirstBlood,
        points: d.pointsAwarded
      })),
      myDiscovery: vuln.discovered.some((d: any) => 
        d.user.toString() === userId.toString()
      )
    }));

    return {
      myScore: progress?.score || 0,
      myVulnerabilitiesFound: progress?.vulnerabilityScannerRace?.vulnerabilitiesFound || 0,
      myFirstBloods: progress?.vulnerabilityScannerRace?.firstBloods || 0,
      myInvalidSubmissions: progress?.vulnerabilityScannerRace?.invalidSubmissions || 0,
      vulnerabilitiesStatus,
      totalVulnerabilities: scenario.data.totalVulnerabilities,
      targetUrl: scenario.data.targetUrl,
      targetName: scenario.data.targetName,
      features: scenario.data.features
    };

  } catch (error) {
    console.error('[getGameState] Error:', error);
    return null;
  }
}