// services/vulnerabilityScannerRace/vulnerabilityScannerEngine.ts

import Arena from '../../models/Arena';
import ArenaProgress from '../../models/ArenaProgress';

/**
 * ğŸ” Vulnerability Scanner Race Engine
 *
 * ì·¨ì•½ì  ì œì¶œ ê²€ì¦, ì ìˆ˜ ê³„ì‚°, ê²Œì„ ìƒíƒœ ê´€ë¦¬
 */

// âœ… Helper: í™œì„± ë²„í”„ ê°€ì ¸ì˜¤ê¸°
const getActiveBuffs = (arena: any, userId: string) => {
  const participant = arena.participants.find(
    (p: any) => String((p.user as any)?._id ?? p.user) === userId
  );

  if (!participant || !participant.activeBuffs) return [];

  const now = new Date();
  return participant.activeBuffs.filter((buff: any) => {
    return buff.expiresAt && new Date(buff.expiresAt) > now;
  });
};

// âœ… Helper: ì ìˆ˜ ë¶€ìŠ¤íŠ¸ ì ìš©
const applyScoreBoost = (baseScore: number, buffs: any[]) => {
  const scoreBoostBuff = buffs.find((b: any) => b.type === 'score_boost');
  if (!scoreBoostBuff || !scoreBoostBuff.value) return baseScore;

  const multiplier = 1 + (scoreBoostBuff.value / 100);
  return Math.floor(baseScore * multiplier);
};

// âœ… Helper: ë¬´ì  ìƒíƒœ ì²´í¬
const hasInvincible = (buffs: any[]) => {
  return buffs.some((b: any) => b.type === 'invincible');
};

interface VulnerabilitySubmission {
  arenaId: string;
  userId: string;
  vulnType: string;
  flag: string;  // FLAG{...} í˜•ì‹
}

interface SubmissionResult {
  success: boolean;
  message: string;
  isCorrect: boolean;
  isFirstBlood: boolean;
  pointsAwarded: number;
  breakdown?: {
    basePoints: number;
    firstBloodBonus: number;
    speedBonus: number;
    comboBonus: number;
  };
  vulnInfo?: {
    vulnId: string;
    vulnType: string;
    vulnName: string;
  };
}

/**
 * âœ… ì·¨ì•½ì  ì œì¶œ ì²˜ë¦¬
 */
export async function processVulnerabilitySubmission(
  submission: VulnerabilitySubmission
): Promise<SubmissionResult> {

  const { arenaId, userId, vulnType, flag } = submission;

  try {
    // 1. Arena ì¡°íšŒ
    const arena = await Arena.findById(arenaId).populate('scenarioId');

    if (!arena) {
      return {
        success: false,
        message: 'Arena not found',
        isCorrect: false,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    if (arena.status !== 'started') {
      return {
        success: false,
        message: 'Arena not started',
        isCorrect: false,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    const scenario = arena.scenarioId as any;
    const scenarioData = scenario.data;

    console.log(`ğŸ” [processVulnerabilitySubmission] Submitted:`, { vulnType, flag });
    console.log(`ğŸ” [processVulnerabilitySubmission] Available vulnerabilities:`,
      scenarioData.vulnerabilities.map((v: any) => ({
        vulnId: v.vulnId,
        vulnType: v.vulnType,
        flag: v.flag
      }))
    );

    // 2. FLAGë¡œ ì·¨ì•½ì  ì°¾ê¸°
    const vulnerability = scenarioData.vulnerabilities.find((v: any) =>
      v.flag === flag && v.vulnType === vulnType
    );

    if (!vulnerability) {
      // ì˜ëª»ëœ FLAG - í˜ë„í‹°
      return await applyInvalidSubmissionPenalty(arenaId, userId, {
        vulnType,
        flag
      });
    }

    // 3. ì´ë¯¸ ë°œê²¬í–ˆëŠ”ì§€ í™•ì¸
    const alreadyDiscovered = await checkIfAlreadyDiscovered(
      arenaId,
      userId,
      vulnerability.vulnId
    );

    if (alreadyDiscovered) {
      return {
        success: false,
        message: 'You already discovered this vulnerability',
        isCorrect: true,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    // FLAGê°€ ì¼ì¹˜í•˜ë©´ ë°”ë¡œ ì„±ê³µ (ë³„ë„ payload ê²€ì¦ ë¶ˆí•„ìš”)

    // 5. First Blood í™•ì¸
    const isFirstBlood = await checkFirstBlood(arenaId, vulnerability.vulnId);

    // 6. ì ìˆ˜ ê³„ì‚°
    const points = await calculatePoints(
      arenaId,
      userId,
      vulnerability,
      isFirstBlood
    );

    // 7. Arenaì— ë°œê²¬ ê¸°ë¡
    await recordDiscovery(arenaId, userId, vulnerability.vulnId, points.total);

    // 8. ArenaProgress ì—…ë°ì´íŠ¸
    await updatePlayerProgress(
      arenaId,
      userId,
      vulnerability,
      flag,
      isFirstBlood,
      points
    );

    // 9. ì™„ë£Œ ì²´í¬ëŠ” Handlerì—ì„œ ì²˜ë¦¬
    // (ì—¬ê¸°ì„œ checkGameCompletionì„ í˜¸ì¶œí•˜ë©´ ì¤‘ë³µ í˜¸ì¶œë¨)

    return {
      success: true,
      message: `âœ… ${vulnerability.vulnName} discovered!`,
      isCorrect: true,
      isFirstBlood,
      pointsAwarded: points.total,
      breakdown: {
        basePoints: points.base,
        firstBloodBonus: points.firstBlood,
        speedBonus: points.speed,
        comboBonus: points.combo
      },
      vulnInfo: {
        vulnId: vulnerability.vulnId,
        vulnType: vulnerability.vulnType,
        vulnName: vulnerability.vulnName
      }
    };

  } catch (error) {
    console.error('[processVulnerabilitySubmission] Error:', error);
    return {
      success: false,
      message: 'Error processing submission',
      isCorrect: false,
      isFirstBlood: false,
      pointsAwarded: 0
    };
  }
}

/**
 * ğŸ©¸ First Blood í™•ì¸
 */
async function checkFirstBlood(
  arenaId: string,
  vulnId: string
): Promise<boolean> {
  
  const arena = await Arena.findById(arenaId);
  if (!arena) return false;

  const modeSettings = arena.modeSettings?.vulnerabilityScannerRace;
  if (!modeSettings) return false;

  const vuln = modeSettings.vulnerabilities.find((v: any) => v.vulnId === vulnId);
  if (!vuln) return false;

  return vuln.discovered.length === 0;
}

/**
 * ğŸ¯ ì ìˆ˜ ê³„ì‚°
 *
 * âœ… Vulnerability Scanner Race: ë³´ë„ˆìŠ¤ ì—†ìŒ, ì•„ì´í…œ ì‚¬ìš© ì‹œì—ë§Œ ì ìˆ˜ ì¦ê°€
 */
async function calculatePoints(
  arenaId: string,
  userId: string,
  vulnerability: any,
  isFirstBlood: boolean
): Promise<{
  base: number;
  firstBlood: number;
  speed: number;
  combo: number;
  total: number;
}> {

  const arena = await Arena.findById(arenaId).populate('scenarioId');

  // ê¸°ë³¸ ì ìˆ˜ë§Œ ì‚¬ìš©
  const basePoints = vulnerability.basePoints || 100;

  // âœ… ì ìˆ˜ ë¶€ìŠ¤íŠ¸ ì•„ì´í…œë§Œ ì ìš© (ë‹¤ë¥¸ ë³´ë„ˆìŠ¤ ì—†ìŒ)
  const activeBuffs = getActiveBuffs(arena, userId);
  const total = applyScoreBoost(basePoints, activeBuffs);

  if (total !== basePoints) {
    console.log(`ğŸš€ Score boost item applied: ${basePoints} â†’ ${total}`);
  }

  return {
    base: basePoints,
    firstBlood: 0,
    speed: 0,
    combo: 0,
    total
  };
}

/**
 * ğŸ“ Arenaì— ë°œê²¬ ê¸°ë¡
 */
async function recordDiscovery(
  arenaId: string,
  userId: string,
  vulnId: string,
  pointsAwarded: number
): Promise<void> {
  
  await Arena.updateOne(
    {
      _id: arenaId,
      'modeSettings.vulnerabilityScannerRace.vulnerabilities.vulnId': vulnId
    },
    {
      $push: {
        'modeSettings.vulnerabilityScannerRace.vulnerabilities.$.discovered': {
          user: userId,
          discoveredAt: new Date(),
          pointsAwarded,
          isFirstBlood: false // ì¼ë‹¨ falseë¡œ ì„¤ì •, ë‚˜ì¤‘ì— ì—…ë°ì´íŠ¸
        }
      }
    }
  );

  // First Bloodì¸ì§€ í™•ì¸í•˜ê³  ì—…ë°ì´íŠ¸
  const arena = await Arena.findById(arenaId);
  const vuln = arena?.modeSettings?.vulnerabilityScannerRace?.vulnerabilities.find(
    (v: any) => v.vulnId === vulnId
  );

  if (vuln && vuln.discovered.length === 1) {
    // ì²« ë°œê²¬ì´ë©´ isFirstBloodë¥¼ trueë¡œ ì—…ë°ì´íŠ¸
    await Arena.updateOne(
      {
        _id: arenaId,
        'modeSettings.vulnerabilityScannerRace.vulnerabilities.vulnId': vulnId
      },
      {
        $set: {
          'modeSettings.vulnerabilityScannerRace.vulnerabilities.$.discovered.0.isFirstBlood': true
        }
      }
    );
  }
}

/**
 * ğŸ“Š í”Œë ˆì´ì–´ ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
 */
async function updatePlayerProgress(
  arenaId: string,
  userId: string,
  vulnerability: any,
  flag: string,
  isFirstBlood: boolean,
  points: {
    base: number;
    firstBlood: number;
    speed: number;
    combo: number;
    total: number;
  }
): Promise<void> {

  await ArenaProgress.updateOne(
    { arena: arenaId, user: userId },
    {
      $inc: {
        score: points.total,
        'vulnerabilityScannerRace.vulnerabilitiesFound': 1,
        'vulnerabilityScannerRace.firstBloods': isFirstBlood ? 1 : 0,
        'vulnerabilityScannerRace.speedBonusPoints': points.speed,
        'vulnerabilityScannerRace.comboPoints': points.combo
      },
      $push: {
        'vulnerabilityScannerRace.discoveries': {
          vulnId: vulnerability.vulnId,
          vulnType: vulnerability.vulnType,
          vulnName: vulnerability.vulnName,
          flag,
          discoveredAt: new Date(),
          isFirstBlood,
          basePoints: points.base,
          speedBonus: points.speed,
          comboBonus: points.combo,
          totalPoints: points.total
        },
        'vulnerabilityScannerRace.submissions': {
          vulnType: vulnerability.vulnType,
          flag,
          isCorrect: true,
          pointsChange: points.total,
          submittedAt: new Date()
        }
      }
    }
  );
}

/**
 * âŒ ì˜ëª»ëœ ì œì¶œ í˜ë„í‹°
 */
async function applyInvalidSubmissionPenalty(
  arenaId: string,
  userId: string,
  submission: {
    vulnType: string;
    flag: string;
  }
): Promise<SubmissionResult> {

  const arena = await Arena.findById(arenaId).populate('scenarioId');
  const scenario = arena?.scenarioId as any;

  // âœ… ë¬´ì  ìƒíƒœë©´ íŒ¨ë„í‹° ë¬´ì‹œ
  const activeBuffs = getActiveBuffs(arena, userId);
  const isInvincible = hasInvincible(activeBuffs);

  let penalty = 0;
  let message = '';

  if (isInvincible) {
    penalty = 0;
    message = `âš ï¸ Incorrect submission (No penalty - Invincible active)`;
    console.log(`ğŸ›¡ï¸ Invincible active: penalty ignored for user ${userId}`);
  } else {
    penalty = scenario?.data?.scoring?.invalidSubmissionPenalty || 5;
    message = `âŒ Incorrect submission. -${penalty} points`;
  }

  await ArenaProgress.updateOne(
    { arena: arenaId, user: userId },
    {
      $inc: {
        score: -penalty,
        'vulnerabilityScannerRace.invalidSubmissions': 1
      },
      $push: {
        'vulnerabilityScannerRace.submissions': {
          vulnType: submission.vulnType,
          flag: submission.flag,
          isCorrect: false,
          pointsChange: -penalty,
          submittedAt: new Date()
        }
      }
    }
  );

  return {
    success: false,
    message,
    isCorrect: false,
    isFirstBlood: false,
    pointsAwarded: -penalty
  };
}

/**
 * ğŸ” ì´ë¯¸ ë°œê²¬í–ˆëŠ”ì§€ í™•ì¸
 */
async function checkIfAlreadyDiscovered(
  arenaId: string,
  userId: string,
  vulnId: string
): Promise<boolean> {
  
  const progress = await ArenaProgress.findOne({ arena: arenaId, user: userId });
  
  if (!progress || !progress.vulnerabilityScannerRace || !progress.vulnerabilityScannerRace.discoveries) {
    return false;
  }

  return progress.vulnerabilityScannerRace.discoveries.some(
    (d: any) => d.vulnId === vulnId
  );
}

/**
 * â±ï¸ ì‹œê°„ ë³´ë„ˆìŠ¤ ê³„ì‚°
 * - ë¹ ë¥¸ ì™„ë£Œ ì‹œ ì¶”ê°€ ì ìˆ˜ ë¶€ì—¬
 * - ê¸°ì¤€: timeLimitì˜ 50% ì´ë‚´ ì™„ë£Œ ì‹œ ìµœëŒ€ ë³´ë„ˆìŠ¤
 */
function calculateTimeBonus(
  startTime: Date,
  completedAt: Date,
  timeLimit: number // ì´ˆ ë‹¨ìœ„
): number {
  const elapsedSec = Math.floor((completedAt.getTime() - startTime.getTime()) / 1000);
  const halfTimeLimit = timeLimit / 2;

  // ì‹œê°„ ì œí•œì˜ 50% ì´ë‚´ ì™„ë£Œ ì‹œ ìµœëŒ€ ë³´ë„ˆìŠ¤ (50ì )
  // 50% ~ 100% ì‚¬ì´ëŠ” ì„ í˜• ê°ì†Œ
  // 100% ì´ˆê³¼ ì‹œ ë³´ë„ˆìŠ¤ ì—†ìŒ

  const MAX_TIME_BONUS = 50;

  if (elapsedSec <= halfTimeLimit) {
    // 50% ì´ë‚´ ì™„ë£Œ: ìµœëŒ€ ë³´ë„ˆìŠ¤
    return MAX_TIME_BONUS;
  } else if (elapsedSec <= timeLimit) {
    // 50% ~ 100%: ì„ í˜• ê°ì†Œ
    const remainingRatio = (timeLimit - elapsedSec) / halfTimeLimit;
    return Math.floor(MAX_TIME_BONUS * remainingRatio);
  }

  return 0; // ì‹œê°„ ì´ˆê³¼
}

/**
 * ğŸ ê²Œì„ ì™„ë£Œ ì²´í¬
 * @returns {boolean} ì²« ì™„ì£¼ì ë°œìƒ ì—¬ë¶€
 */
export async function checkGameCompletion(arenaId: string): Promise<boolean> {

  const arena = await Arena.findById(arenaId).populate('scenarioId');
  if (!arena) return false;

  const scenario = arena.scenarioId as any;
  const totalVulns = scenario.data?.vulnerabilities?.length || 0;

  console.log(`ğŸ” [checkGameCompletion] Total vulnerabilities: ${totalVulns}`);

  // ëª¨ë“  ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆëŠ”ì§€ í™•ì¸
  const allProgress = await ArenaProgress.find({ arena: arenaId });

  // ì™„ì£¼í•œ í”Œë ˆì´ì–´ë“¤ ì°¾ê¸°
  const completers = allProgress.filter((progress: any) => {
    const found = progress.vulnerabilityScannerRace?.vulnerabilitiesFound || 0;
    console.log(`   Player ${progress.user}: ${found}/${totalVulns} vulnerabilities found`);
    return found >= totalVulns;
  });

  if (completers.length === 0) {
    // ì•„ì§ ì™„ì£¼í•œ ì‚¬ëŒ ì—†ìŒ
    return false;
  }

  const modeSettings = arena.modeSettings?.vulnerabilityScannerRace;
  if (!modeSettings) return false;

  // ì²« ì™„ì£¼ìì¸ì§€ í™•ì¸
  if (!arena.winner) {
    // ğŸ† ì²« ì™„ì£¼ì ë“±ì¥!
    const firstCompleter = completers[0];
    console.log(`ğŸ† [checkGameCompletion] First completer: ${firstCompleter.user}`);

    const submittedAt = new Date();
    const startTime = arena.startTime ? new Date(arena.startTime) : submittedAt;
    const timeLimit = arena.timeLimit || 600; // ê¸°ë³¸ 10ë¶„

    // âœ… ì‹œê°„ ë³´ë„ˆìŠ¤ ê³„ì‚° ë° ì ìš©
    const timeBonus = calculateTimeBonus(startTime, submittedAt, timeLimit);
    console.log(`â±ï¸ [checkGameCompletion] Time bonus for first completer: +${timeBonus} points`);

    // Arenaì— winner ì„¤ì •
    await Arena.updateOne(
      { _id: arenaId },
      {
        $set: {
          winner: firstCompleter.user,
          firstSolvedAt: submittedAt
        }
      }
    );

    // ArenaProgressì— completed ì„¤ì • + ì‹œê°„ ë³´ë„ˆìŠ¤ ì ìš©
    await ArenaProgress.updateOne(
      { _id: firstCompleter._id },
      {
        $set: {
          completed: true,
          submittedAt
        },
        $inc: {
          score: timeBonus,
          'vulnerabilityScannerRace.timeBonusPoints': timeBonus
        }
      }
    );

    console.log(`âœ… [checkGameCompletion] First completer score updated with time bonus: +${timeBonus}`);
    return true; // âœ… ì²« ì™„ì£¼ì ë°œìƒ
  }

  // ğŸ• ì´ë¯¸ winnerê°€ ìˆëŠ” ê²½ìš° (grace period ì¤‘) - ì¶”ê°€ ì™„ì£¼ì ì²˜ë¦¬
  console.log(`â³ [checkGameCompletion] Grace period active, completers: ${completers.length}`);

  // âœ… ìƒˆë¡œ ì™„ì£¼í•œ í”Œë ˆì´ì–´ë“¤ì—ê²Œ ì‹œê°„ ë³´ë„ˆìŠ¤ ì ìš© (ì•„ì§ completedê°€ falseì¸ ì™„ì£¼ìë“¤)
  for (const completer of completers) {
    if (!completer.completed) {
      const submittedAt = new Date();
      const startTime = arena.startTime ? new Date(arena.startTime) : submittedAt;
      const timeLimit = arena.timeLimit || 600;

      const timeBonus = calculateTimeBonus(startTime, submittedAt, timeLimit);
      console.log(`â±ï¸ [checkGameCompletion] Time bonus for player ${completer.user}: +${timeBonus} points`);

      await ArenaProgress.updateOne(
        { _id: completer._id },
        {
          $set: {
            completed: true,
            submittedAt
          },
          $inc: {
            score: timeBonus,
            'vulnerabilityScannerRace.timeBonusPoints': timeBonus
          }
        }
      );
    }
  }

  // âš ï¸ ì—¬ê¸°ê°€ í•µì‹¬! grace period ì¤‘ì—ëŠ” í•­ìƒ falseë¥¼ ë°˜í™˜í•´ì•¼ í•¨
  // Handlerì—ì„œ arena.winner ì²´í¬ë¡œ grace period ë¡œì§ì„ ì²˜ë¦¬í•˜ê¸° ë•Œë¬¸
  return false;
}


/**
 * ğŸ’¡ íŒíŠ¸ ìš”ì²­ ì²˜ë¦¬
 */
export async function requestHint(
  arenaId: string,
  userId: string,
  vulnId: string,
  hintLevel: number
): Promise<{
  success: boolean;
  hint?: string;
  cost?: number;
  message?: string;
}> {
  
  try {
    const arena = await Arena.findById(arenaId).populate('scenarioId');
    if (!arena) {
      return { success: false, message: 'Arena not found' };
    }

    const scenario = arena.scenarioId as any;
    const hints = scenario.data.hints || [];

    const hint = hints.find((h: any) => 
      h.vulnId === vulnId && h.level === hintLevel
    );

    if (!hint) {
      return { success: false, message: 'Hint not found' };
    }

    // ì ìˆ˜ ì°¨ê°
    await ArenaProgress.updateOne(
      { arena: arenaId, user: userId },
      {
        $inc: {
          score: -hint.cost,
          'vulnerabilityScannerRace.hintsUsed': 1
        }
      }
    );

    return {
      success: true,
      hint: hint.text,
      cost: hint.cost
    };

  } catch (error) {
    console.error('[requestHint] Error:', error);
    return { success: false, message: 'Error requesting hint' };
  }
}

/**
 * ğŸ“Š í˜„ì¬ ê²Œì„ ìƒíƒœ ì¡°íšŒ
 */
export async function getGameState(
  arenaId: string,
  userId: string
): Promise<any> {

  try {
    const arena = await Arena.findById(arenaId).populate('scenarioId');
    if (!arena) return null;

    const scenario = arena.scenarioId as any;
    const progress = await ArenaProgress.findOne({ arena: arenaId, user: userId });

    // ëª¨ë“  ì°¸ê°€ì ì§„í–‰ ìƒí™© ì¡°íšŒ (ë¦¬ë”ë³´ë“œìš©)
    const allProgress = await ArenaProgress.find({ arena: arenaId })
      .populate('user', 'username')
      .sort({ score: -1 })
      .lean();

    // ë¦¬ë”ë³´ë“œ ìƒì„±
    const leaderboard = allProgress.map((p: any, index: number) => {
      const pUser = p.user as any;
      return {
        userId: String(pUser._id),
        username: pUser.username,
        score: p.score || 0,
        vulnerabilitiesFound: p.vulnerabilityScannerRace?.vulnerabilitiesFound || 0
      };
    });

    // ë‚´ ìˆœìœ„ ê³„ì‚°
    const myRank = allProgress.findIndex((p: any) =>
      p.user._id.toString() === userId.toString()
    ) + 1;

    // ë°œê²¬ëœ ì·¨ì•½ì  ëª©ë¡
    const discoveredVulns = arena.modeSettings?.vulnerabilityScannerRace?.vulnerabilities || [];

    // ë‚´ê°€ ë°œê²¬í•œ ì·¨ì•½ì  ID ëª©ë¡
    const myFoundVulnIds = discoveredVulns
      .filter((vuln: any) =>
        vuln.discovered.some((d: any) => d.user.toString() === userId.toString())
      )
      .map((vuln: any) => vuln.vulnId);

    // ì·¨ì•½ì  ëª©ë¡ (í”„ë¡ íŠ¸ì—”ë“œ í˜•ì‹)
    const vulnerabilities = discoveredVulns.map((vuln: any) => {
      const firstDiscovery = vuln.discovered.find((d: any) => d.isFirstBlood);

      const discoverer = firstDiscovery ?
        allProgress.find((p: any) => (p.user as any)?._id?.toString() === firstDiscovery.user.toString()) :
        null;

      const scenarioVuln = scenario.data.vulnerabilities.find((v: any) => v.vulnId === vuln.vulnId);

      // vulnNameì´ ê°ì²´({ko, en})ì¸ ê²½ìš° ì²˜ë¦¬
      let vulnName = scenarioVuln?.vulnName || 'Unknown';
      if (typeof vulnName === 'object' && vulnName !== null) {
        vulnName = vulnName.en || vulnName.ko || 'Unknown';
      }

      return {
        vulnId: vuln.vulnId,
        name: vulnName,
        type: vuln.vulnType,
        severity: scenarioVuln?.difficulty || 'MEDIUM',
        points: vuln.basePoints || 0,
        discoveredBy: firstDiscovery?.user?.toString(),
        discoveredByUsername: discoverer ? (discoverer.user as any)?.username : undefined,
        isFirstBlood: !!firstDiscovery
      };
    });

    return {
      targetUrl: scenario.data.targetUrl || '',
      targetName: scenario.data.targetName || 'Unknown Target',
      targetDescription: scenario.data.targetDescription || '',
      mode: arena.modeSettings?.vulnerabilityScannerRace?.mode || 'SIMULATED',
      vulnerableHTML: arena.modeSettings?.vulnerabilityScannerRace?.vulnerableHTML || '',
      vulnerabilities,
      hints: scenario.data.hints || [],
      leaderboard,
      myProgress: {
        score: progress?.score || 0,
        foundVulnerabilities: myFoundVulnIds,
        rank: myRank
      }
    };

  } catch (error) {
    console.error('[getGameState] Error:', error);
    return null;
  }
}