// services/vulnerabilityScannerRace/vulnerabilityScannerEngine.ts

import Arena from '../../models/Arena';
import ArenaProgress from '../../models/ArenaProgress';
import mongoose from 'mongoose';

/**
 * ğŸ” Vulnerability Scanner Race Engine
 *
 * ì·¨ì•½ì  ì œì¶œ ê²€ì¦, ì ìˆ˜ ê³„ì‚°, ê²Œì„ ìƒíƒœ ê´€ë¦¬
 */

// âœ… Helper: í™œì„± ë²„í”„ ê°€ì ¸ì˜¤ê¸°
const getActiveBuffs = (arena: any, userId: string) => {
  const participant = arena.participants.find(
    (p: any) => String((p.user as any)?._id ?? p.user) === userId
  );

  if (!participant || !participant.activeBuffs) return [];

  const now = new Date();
  return participant.activeBuffs.filter((buff: any) => {
    return buff.expiresAt && new Date(buff.expiresAt) > now;
  });
};

// âœ… Helper: ì ìˆ˜ ë¶€ìŠ¤íŠ¸ ì ìš©
const applyScoreBoost = (baseScore: number, buffs: any[]) => {
  const scoreBoostBuff = buffs.find((b: any) => b.type === 'score_boost');
  if (!scoreBoostBuff || !scoreBoostBuff.value) return baseScore;

  const multiplier = 1 + (scoreBoostBuff.value / 100);
  return Math.floor(baseScore * multiplier);
};

// âœ… Helper: ë¬´ì  ìƒíƒœ ì²´í¬
const hasInvincible = (buffs: any[]) => {
  return buffs.some((b: any) => b.type === 'invincible');
};

interface VulnerabilitySubmission {
  arenaId: string;
  userId: string;
  vulnType: string;
  endpoint: string;
  parameter: string;
  payload: string;
}

interface SubmissionResult {
  success: boolean;
  message: string;
  isCorrect: boolean;
  isFirstBlood: boolean;
  pointsAwarded: number;
  breakdown?: {
    basePoints: number;
    firstBloodBonus: number;
    speedBonus: number;
    comboBonus: number;
  };
  vulnInfo?: {
    vulnId: string;
    vulnType: string;
    vulnName: string;
  };
}

/**
 * âœ… ì·¨ì•½ì  ì œì¶œ ì²˜ë¦¬
 */
export async function processVulnerabilitySubmission(
  submission: VulnerabilitySubmission
): Promise<SubmissionResult> {
  
  const { arenaId, userId, vulnType, endpoint, parameter, payload } = submission;

  try {
    // 1. Arena ì¡°íšŒ
    const arena = await Arena.findById(arenaId).populate('scenarioId');

    if (!arena) {
      return {
        success: false,
        message: 'Arena not found',
        isCorrect: false,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    if (arena.status !== 'started') {
      return {
        success: false,
        message: 'Arena not started',
        isCorrect: false,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    const scenario = arena.scenarioId as any;
    const scenarioData = scenario.data;

    console.log(`ğŸ” [processVulnerabilitySubmission] Submitted:`, { vulnType, endpoint, parameter, payload });
    console.log(`ğŸ” [processVulnerabilitySubmission] Available vulnerabilities:`,
      scenarioData.vulnerabilities.map((v: any) => ({
        vulnType: v.vulnType,
        endpoint: v.endpoint,
        parameter: v.parameter,
        expectedPayload: v.validation?.expectedPayload
      }))
    );

    // 2. ì œì¶œí•œ ì·¨ì•½ì  ì°¾ê¸°
    const vulnerability = scenarioData.vulnerabilities.find((v: any) =>
      v.vulnType === vulnType &&
      v.endpoint === endpoint &&
      (v.parameter === parameter || v.parameter === '')
    );

    if (!vulnerability) {
      // ì˜ëª»ëœ ì œì¶œ - í˜ë„í‹°
      return await applyInvalidSubmissionPenalty(arenaId, userId, {
        vulnType,
        endpoint,
        parameter,
        payload
      });
    }

    // 3. ì´ë¯¸ ë°œê²¬í–ˆëŠ”ì§€ í™•ì¸
    const alreadyDiscovered = await checkIfAlreadyDiscovered(
      arenaId, 
      userId, 
      vulnerability.vulnId
    );

    if (alreadyDiscovered) {
      return {
        success: false,
        message: 'You already discovered this vulnerability',
        isCorrect: true,
        isFirstBlood: false,
        pointsAwarded: 0
      };
    }

    // 4. í˜ì´ë¡œë“œ ê²€ì¦
    const isValidPayload = await validatePayload(vulnerability, payload);
    
    if (!isValidPayload) {
      // ì˜¬ë°”ë¥¸ ì·¨ì•½ì ì´ì§€ë§Œ í˜ì´ë¡œë“œê°€ í‹€ë¦¼ - í˜ë„í‹°
      return await applyInvalidSubmissionPenalty(arenaId, userId, {
        vulnType,
        endpoint,
        parameter,
        payload
      });
    }

    // 5. First Blood í™•ì¸
    const isFirstBlood = await checkFirstBlood(arenaId, vulnerability.vulnId);

    // 6. ì ìˆ˜ ê³„ì‚°
    const points = await calculatePoints(
      arenaId,
      userId,
      vulnerability,
      isFirstBlood
    );

    // 7. Arenaì— ë°œê²¬ ê¸°ë¡
    await recordDiscovery(arenaId, userId, vulnerability.vulnId, points.total);

    // 8. ArenaProgress ì—…ë°ì´íŠ¸
    await updatePlayerProgress(
      arenaId,
      userId,
      vulnerability,
      payload,
      isFirstBlood,
      points
    );

    // 9. ì™„ë£Œ ì²´í¬ëŠ” Handlerì—ì„œ ì²˜ë¦¬
    // (ì—¬ê¸°ì„œ checkGameCompletionì„ í˜¸ì¶œí•˜ë©´ ì¤‘ë³µ í˜¸ì¶œë¨)

    return {
      success: true,
      message: `âœ… ${vulnerability.vulnName} discovered!`,
      isCorrect: true,
      isFirstBlood,
      pointsAwarded: points.total,
      breakdown: {
        basePoints: points.base,
        firstBloodBonus: points.firstBlood,
        speedBonus: points.speed,
        comboBonus: points.combo
      },
      vulnInfo: {
        vulnId: vulnerability.vulnId,
        vulnType: vulnerability.vulnType,
        vulnName: vulnerability.vulnName
      }
    };

  } catch (error) {
    console.error('[processVulnerabilitySubmission] Error:', error);
    return {
      success: false,
      message: 'Error processing submission',
      isCorrect: false,
      isFirstBlood: false,
      pointsAwarded: 0
    };
  }
}

/**
 * ğŸ” í˜ì´ë¡œë“œ ê²€ì¦
 */
async function validatePayload(
  vulnerability: any,
  payload: string
): Promise<boolean> {

  const { validation } = vulnerability;

  if (!validation) {
    return true; // ê²€ì¦ ë¡œì§ì´ ì—†ìœ¼ë©´ í†µê³¼
  }

  // Ensure payload is a string
  const payloadStr = String(payload || '');

  // Support both validationMethod and method
  const method = validation.validationMethod || validation.method;
  const expectedPayload = validation.expectedPayload;

  switch (method) {
    case 'exact':
      // ì •í™•íˆ ì¼ì¹˜
      return payloadStr === expectedPayload;

    case 'contains':
    case 'pattern':
      // í¬í•¨ ì—¬ë¶€
      return payloadStr.includes(expectedPayload || '');

    case 'regex':
      // ì •ê·œí‘œí˜„ì‹
      const pattern = validation.validationCriteria?.pattern || expectedPayload;
      if (pattern) {
        try {
          const regex = new RegExp(pattern);
          return regex.test(payloadStr);
        } catch {
          return payloadStr.includes(pattern);
        }
      }
      return true;

    case 'stored':
    case 'unauthorized_access':
    case 'missing_token':
      // ì‹¤ì œ ê²€ì¦ì´ í•„ìš”í•œ ê²½ìš° - ê°„ë‹¨í•˜ê²Œ expectedPayload í¬í•¨ ì—¬ë¶€ë¡œ ì²´í¬
      if (expectedPayload) {
        return payloadStr.toLowerCase().includes(expectedPayload.toLowerCase());
      }
      return true;

    default:
      return true;
  }
}

/**
 * ğŸ©¸ First Blood í™•ì¸
 */
async function checkFirstBlood(
  arenaId: string,
  vulnId: string
): Promise<boolean> {
  
  const arena = await Arena.findById(arenaId);
  if (!arena) return false;

  const modeSettings = arena.modeSettings?.vulnerabilityScannerRace;
  if (!modeSettings) return false;

  const vuln = modeSettings.vulnerabilities.find((v: any) => v.vulnId === vulnId);
  if (!vuln) return false;

  return vuln.discovered.length === 0;
}

/**
 * ğŸ¯ ì ìˆ˜ ê³„ì‚°
 *
 * âœ… Vulnerability Scanner Race: ë³´ë„ˆìŠ¤ ì—†ìŒ, ì•„ì´í…œ ì‚¬ìš© ì‹œì—ë§Œ ì ìˆ˜ ì¦ê°€
 */
async function calculatePoints(
  arenaId: string,
  userId: string,
  vulnerability: any,
  isFirstBlood: boolean
): Promise<{
  base: number;
  firstBlood: number;
  speed: number;
  combo: number;
  total: number;
}> {

  const arena = await Arena.findById(arenaId).populate('scenarioId');

  // ê¸°ë³¸ ì ìˆ˜ë§Œ ì‚¬ìš©
  const basePoints = vulnerability.basePoints || 100;

  // âœ… ì ìˆ˜ ë¶€ìŠ¤íŠ¸ ì•„ì´í…œë§Œ ì ìš© (ë‹¤ë¥¸ ë³´ë„ˆìŠ¤ ì—†ìŒ)
  const activeBuffs = getActiveBuffs(arena, userId);
  const total = applyScoreBoost(basePoints, activeBuffs);

  if (total !== basePoints) {
    console.log(`ğŸš€ Score boost item applied: ${basePoints} â†’ ${total}`);
  }

  return {
    base: basePoints,
    firstBlood: 0,
    speed: 0,
    combo: 0,
    total
  };
}

/**
 * ğŸ“ Arenaì— ë°œê²¬ ê¸°ë¡
 */
async function recordDiscovery(
  arenaId: string,
  userId: string,
  vulnId: string,
  pointsAwarded: number
): Promise<void> {
  
  await Arena.updateOne(
    {
      _id: arenaId,
      'modeSettings.vulnerabilityScannerRace.vulnerabilities.vulnId': vulnId
    },
    {
      $push: {
        'modeSettings.vulnerabilityScannerRace.vulnerabilities.$.discovered': {
          user: userId,
          discoveredAt: new Date(),
          pointsAwarded,
          isFirstBlood: false // ì¼ë‹¨ falseë¡œ ì„¤ì •, ë‚˜ì¤‘ì— ì—…ë°ì´íŠ¸
        }
      }
    }
  );

  // First Bloodì¸ì§€ í™•ì¸í•˜ê³  ì—…ë°ì´íŠ¸
  const arena = await Arena.findById(arenaId);
  const vuln = arena?.modeSettings?.vulnerabilityScannerRace?.vulnerabilities.find(
    (v: any) => v.vulnId === vulnId
  );

  if (vuln && vuln.discovered.length === 1) {
    // ì²« ë°œê²¬ì´ë©´ isFirstBloodë¥¼ trueë¡œ ì—…ë°ì´íŠ¸
    await Arena.updateOne(
      {
        _id: arenaId,
        'modeSettings.vulnerabilityScannerRace.vulnerabilities.vulnId': vulnId
      },
      {
        $set: {
          'modeSettings.vulnerabilityScannerRace.vulnerabilities.$.discovered.0.isFirstBlood': true
        }
      }
    );
  }
}

/**
 * ğŸ“Š í”Œë ˆì´ì–´ ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
 */
async function updatePlayerProgress(
  arenaId: string,
  userId: string,
  vulnerability: any,
  payload: string,
  isFirstBlood: boolean,
  points: {
    base: number;
    firstBlood: number;
    speed: number;
    combo: number;
    total: number;
  }
): Promise<void> {
  
  await ArenaProgress.updateOne(
    { arena: arenaId, user: userId },
    {
      $inc: {
        score: points.total,
        'vulnerabilityScannerRace.vulnerabilitiesFound': 1,
        'vulnerabilityScannerRace.firstBloods': isFirstBlood ? 1 : 0,
        'vulnerabilityScannerRace.speedBonusPoints': points.speed,
        'vulnerabilityScannerRace.comboPoints': points.combo
      },
      $push: {
        'vulnerabilityScannerRace.discoveries': {
          vulnId: vulnerability.vulnId,
          vulnType: vulnerability.vulnType,
          vulnName: vulnerability.vulnName,
          payload,
          discoveredAt: new Date(),
          isFirstBlood,
          basePoints: points.base,
          speedBonus: points.speed,
          comboBonus: points.combo,
          totalPoints: points.total
        },
        'vulnerabilityScannerRace.submissions': {
          vulnType: vulnerability.vulnType,
          endpoint: vulnerability.endpoint,
          parameter: vulnerability.parameter,
          payload,
          isCorrect: true,
          pointsChange: points.total,
          submittedAt: new Date()
        }
      }
    }
  );
}

/**
 * âŒ ì˜ëª»ëœ ì œì¶œ í˜ë„í‹°
 */
async function applyInvalidSubmissionPenalty(
  arenaId: string,
  userId: string,
  submission: {
    vulnType: string;
    endpoint: string;
    parameter: string;
    payload: string;
  }
): Promise<SubmissionResult> {

  const arena = await Arena.findById(arenaId).populate('scenarioId');
  const scenario = arena?.scenarioId as any;

  // âœ… ë¬´ì  ìƒíƒœë©´ íŒ¨ë„í‹° ë¬´ì‹œ
  const activeBuffs = getActiveBuffs(arena, userId);
  const isInvincible = hasInvincible(activeBuffs);

  let penalty = 0;
  let message = '';

  if (isInvincible) {
    penalty = 0;
    message = `âš ï¸ Incorrect submission (No penalty - Invincible active)`;
    console.log(`ğŸ›¡ï¸ Invincible active: penalty ignored for user ${userId}`);
  } else {
    penalty = scenario?.data?.scoring?.invalidSubmissionPenalty || 5;
    message = `âŒ Incorrect submission. -${penalty} points`;
  }

  await ArenaProgress.updateOne(
    { arena: arenaId, user: userId },
    {
      $inc: {
        score: -penalty,
        'vulnerabilityScannerRace.invalidSubmissions': 1
      },
      $push: {
        'vulnerabilityScannerRace.submissions': {
          vulnType: submission.vulnType,
          endpoint: submission.endpoint,
          parameter: submission.parameter,
          payload: submission.payload,
          isCorrect: false,
          pointsChange: -penalty,
          submittedAt: new Date()
        }
      }
    }
  );

  return {
    success: true,
    message,
    isCorrect: false,
    isFirstBlood: false,
    pointsAwarded: -penalty
  };
}

/**
 * ğŸ” ì´ë¯¸ ë°œê²¬í–ˆëŠ”ì§€ í™•ì¸
 */
async function checkIfAlreadyDiscovered(
  arenaId: string,
  userId: string,
  vulnId: string
): Promise<boolean> {
  
  const progress = await ArenaProgress.findOne({ arena: arenaId, user: userId });
  
  if (!progress || !progress.vulnerabilityScannerRace || !progress.vulnerabilityScannerRace.discoveries) {
    return false;
  }

  return progress.vulnerabilityScannerRace.discoveries.some(
    (d: any) => d.vulnId === vulnId
  );
}

/**
 * ğŸ ê²Œì„ ì™„ë£Œ ì²´í¬
 * @returns {boolean} ì²« ì™„ì£¼ì ë°œìƒ ì—¬ë¶€
 */
export async function checkGameCompletion(arenaId: string): Promise<boolean> {

  const arena = await Arena.findById(arenaId).populate('scenarioId');
  if (!arena) return false;

  const scenario = arena.scenarioId as any;
  const totalVulns = scenario.data?.vulnerabilities?.length || 0;

  console.log(`ğŸ” [checkGameCompletion] Total vulnerabilities: ${totalVulns}`);

  // ëª¨ë“  ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆëŠ”ì§€ í™•ì¸
  const allProgress = await ArenaProgress.find({ arena: arenaId });

  // ì™„ì£¼í•œ í”Œë ˆì´ì–´ë“¤ ì°¾ê¸°
  const completers = allProgress.filter((progress: any) => {
    const found = progress.vulnerabilityScannerRace?.vulnerabilitiesFound || 0;
    console.log(`   Player ${progress.user}: ${found}/${totalVulns} vulnerabilities found`);
    return found >= totalVulns;
  });

  if (completers.length === 0) {
    // ì•„ì§ ì™„ì£¼í•œ ì‚¬ëŒ ì—†ìŒ
    return false;
  }

  const modeSettings = arena.modeSettings?.vulnerabilityScannerRace;
  if (!modeSettings) return false;

  // ì²« ì™„ì£¼ìì¸ì§€ í™•ì¸
  if (!arena.winner) {
    // ğŸ† ì²« ì™„ì£¼ì ë“±ì¥!
    const firstCompleter = completers[0];
    console.log(`ğŸ† [checkGameCompletion] First completer: ${firstCompleter.user}`);

    const submittedAt = new Date();

    // Arenaì— winner ì„¤ì •
    await Arena.updateOne(
      { _id: arenaId },
      {
        $set: {
          winner: firstCompleter.user,
          firstSolvedAt: submittedAt
        }
      }
    );

    // ArenaProgressì— completed ì„¤ì •
    await ArenaProgress.updateOne(
      { _id: firstCompleter._id },
      {
        $set: {
          completed: true,
          submittedAt
        }
      }
    );

    console.log(`âœ… [checkGameCompletion] Returning true for first completer`);
    return true; // âœ… ì²« ì™„ì£¼ì ë°œìƒ
  }

  // ğŸ• ì´ë¯¸ winnerê°€ ìˆëŠ” ê²½ìš° (grace period ì¤‘)
  console.log(`â³ [checkGameCompletion] Grace period active, completers: ${completers.length}`);
  
  // âš ï¸ ì—¬ê¸°ê°€ í•µì‹¬! grace period ì¤‘ì—ëŠ” í•­ìƒ falseë¥¼ ë°˜í™˜í•´ì•¼ í•¨
  // Handlerì—ì„œ arena.winner ì²´í¬ë¡œ grace period ë¡œì§ì„ ì²˜ë¦¬í•˜ê¸° ë•Œë¬¸
  return false;
}


/**
 * ğŸ’¡ íŒíŠ¸ ìš”ì²­ ì²˜ë¦¬
 */
export async function requestHint(
  arenaId: string,
  userId: string,
  vulnId: string,
  hintLevel: number
): Promise<{
  success: boolean;
  hint?: string;
  cost?: number;
  message?: string;
}> {
  
  try {
    const arena = await Arena.findById(arenaId).populate('scenarioId');
    if (!arena) {
      return { success: false, message: 'Arena not found' };
    }

    const scenario = arena.scenarioId as any;
    const hints = scenario.data.hints || [];

    const hint = hints.find((h: any) => 
      h.vulnId === vulnId && h.level === hintLevel
    );

    if (!hint) {
      return { success: false, message: 'Hint not found' };
    }

    // ì ìˆ˜ ì°¨ê°
    await ArenaProgress.updateOne(
      { arena: arenaId, user: userId },
      {
        $inc: {
          score: -hint.cost,
          'vulnerabilityScannerRace.hintsUsed': 1
        }
      }
    );

    return {
      success: true,
      hint: hint.text,
      cost: hint.cost
    };

  } catch (error) {
    console.error('[requestHint] Error:', error);
    return { success: false, message: 'Error requesting hint' };
  }
}

/**
 * ğŸ“Š í˜„ì¬ ê²Œì„ ìƒíƒœ ì¡°íšŒ
 */
export async function getGameState(
  arenaId: string,
  userId: string
): Promise<any> {

  try {
    const arena = await Arena.findById(arenaId).populate('scenarioId');
    if (!arena) return null;

    const scenario = arena.scenarioId as any;
    const progress = await ArenaProgress.findOne({ arena: arenaId, user: userId });

    // ëª¨ë“  ì°¸ê°€ì ì§„í–‰ ìƒí™© ì¡°íšŒ (ë¦¬ë”ë³´ë“œìš©)
    const allProgress = await ArenaProgress.find({ arena: arenaId })
      .populate('user', 'username')
      .sort({ score: -1 })
      .lean();

    // ë¦¬ë”ë³´ë“œ ìƒì„±
    const leaderboard = allProgress.map((p: any, index: number) => {
      const pUser = p.user as any;
      return {
        userId: String(pUser._id),
        username: pUser.username,
        score: p.score || 0,
        vulnerabilitiesFound: p.vulnerabilityScannerRace?.vulnerabilitiesFound || 0
      };
    });

    // ë‚´ ìˆœìœ„ ê³„ì‚°
    const myRank = allProgress.findIndex((p: any) =>
      p.user._id.toString() === userId.toString()
    ) + 1;

    // ë°œê²¬ëœ ì·¨ì•½ì  ëª©ë¡
    const discoveredVulns = arena.modeSettings?.vulnerabilityScannerRace?.vulnerabilities || [];

    // ë‚´ê°€ ë°œê²¬í•œ ì·¨ì•½ì  ID ëª©ë¡
    const myFoundVulnIds = discoveredVulns
      .filter((vuln: any) =>
        vuln.discovered.some((d: any) => d.user.toString() === userId.toString())
      )
      .map((vuln: any) => vuln.vulnId);

    // ì·¨ì•½ì  ëª©ë¡ (í”„ë¡ íŠ¸ì—”ë“œ í˜•ì‹)
    const vulnerabilities = discoveredVulns.map((vuln: any) => {
      const firstDiscovery = vuln.discovered.find((d: any) => d.isFirstBlood);

      const discoverer = firstDiscovery ?
        allProgress.find((p: any) => (p.user as any)?._id?.toString() === firstDiscovery.user.toString()) :
        null;

      return {
        vulnId: vuln.vulnId,
        name: scenario.data.vulnerabilities.find((v: any) => v.vulnId === vuln.vulnId)?.vulnName || 'Unknown',
        type: vuln.vulnType,
        severity: scenario.data.vulnerabilities.find((v: any) => v.vulnId === vuln.vulnId)?.difficulty || 'MEDIUM',
        points: vuln.basePoints || 0,
        discoveredBy: firstDiscovery?.user?.toString(),
        discoveredByUsername: discoverer ? (discoverer.user as any)?.username : undefined,
        isFirstBlood: !!firstDiscovery
      };
    });

    return {
      targetUrl: scenario.data.targetUrl || '',
      targetName: scenario.data.targetName || 'Unknown Target',
      targetDescription: scenario.data.targetDescription || '',
      mode: arena.modeSettings?.vulnerabilityScannerRace?.mode || 'SIMULATED',
      vulnerableHTML: arena.modeSettings?.vulnerabilityScannerRace?.vulnerableHTML || '',
      vulnerabilities,
      leaderboard,
      myProgress: {
        score: progress?.score || 0,
        foundVulnerabilities: myFoundVulnIds,
        rank: myRank
      }
    };

  } catch (error) {
    console.error('[getGameState] Error:', error);
    return null;
  }
}